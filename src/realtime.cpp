#include "realtime.h"

#include <QCoreApplication>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QImage>
#include <iostream>
#include "settings.h"
#include "utils/shaderloader.h"
#include "camera.h"
#include "utils/sceneparser.h"
#include <cmath>
#include "DefaultScene.h"


// ================== Rendering the Scene!

Realtime::Realtime(QWidget *parent)
    : QOpenGLWidget(parent)
{
    m_prev_mouse_pos = glm::vec2(size().width()/2, size().height()/2);
    setMouseTracking(true);
    setFocusPolicy(Qt::StrongFocus);

    m_keyMap[Qt::Key_W]       = false;
    m_keyMap[Qt::Key_A]       = false;
    m_keyMap[Qt::Key_S]       = false;
    m_keyMap[Qt::Key_D]       = false;
    m_keyMap[Qt::Key_Control] = false;
    m_keyMap[Qt::Key_Space]   = false;

    // If you must use this function, do not edit anything above this
}

namespace {
GLuint loadTextureFromResource(const QString &path) {
    QImage image(path);
    if (image.isNull()) {
        std::cerr << "[Texture] Failed to load: " << path.toStdString() << std::endl;
        return 0;
    }

    QImage glImage = image.convertToFormat(QImage::Format_RGBA8888).mirrored();

    GLuint tex = 0;
    glGenTextures(1, &tex);
    glBindTexture(GL_TEXTURE_2D, tex);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, glImage.width(), glImage.height(),
                 0, GL_RGBA, GL_UNSIGNED_BYTE, glImage.constBits());

    glBindTexture(GL_TEXTURE_2D, 0);
    return tex;
}
}

void Realtime::finish() {
    killTimer(m_timer);
    this->makeCurrent();

    // Students: anything requiring OpenGL calls when the program exits should be done here
    glDeleteBuffers(1, &m_vbo);
    glDeleteVertexArrays(1, &m_vao);

    // For monster (Make sure to release the texture /VAO generated by tinygltf when exiting)
    deleteGlbResources();
    m_meshFiles.clear();

    glDeleteProgram(m_shader);
    if (m_backgroundTex) {
        glDeleteTextures(1, &m_backgroundTex);
        m_backgroundTex = 0;
    }

    this->doneCurrent();
}

void Realtime::initializeGL() {
    m_devicePixelRatio = this->devicePixelRatio();

    m_timer = startTimer(1000/60);
    m_elapsedTimer.start();

    // Initializing GL.
    // GLEW (GL Extension Wrangler) provides access to OpenGL functions.
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK) {
        std::cerr << "Error while initializing GL: " << glewGetErrorString(err) << std::endl;
    }
    std::cout << "Initialized GL: Version " << glewGetString(GLEW_VERSION) << std::endl;

    // Allows OpenGL to draw objects appropriately on top of one another
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glClearColor(0.f, 0.f, 0.f, 1.0f);
    // Tells OpenGL how big the screen is
    glViewport(0, 0, size().width() * m_devicePixelRatio, size().height() * m_devicePixelRatio);

    // Students: anything requiring OpenGL calls when the program starts should be done here
    m_shader = ShaderLoader::createShaderProgram(
        ":/resources/shaders/default.vert",
        ":/resources/shaders/default.frag"
        );

    m_brightShader = ShaderLoader::createShaderProgram(
        ":/resources/shaders/fullscreen_quad.vert",
        ":/resources/shaders/bright.frag"
        );

    m_screenShader = ShaderLoader::createShaderProgram(
        ":/resources/shaders/fullscreen_quad.vert",
        ":/resources/shaders/screen.frag"
        );

    m_blurShader = ShaderLoader::createShaderProgram(
        ":/resources/shaders/fullscreen_quad.vert",
        ":/resources/shaders/blur.frag"
        );

    // ======================
    // NEW: Create Scene FBO
    // ======================
    int w = width() * m_devicePixelRatio;
    int h = height() * m_devicePixelRatio;

    // 1) Create FBO
    glGenFramebuffers(1, &m_sceneFBO);
    glBindFramebuffer(GL_FRAMEBUFFER, m_sceneFBO);

    // 2) Color Texture
    glGenTextures(1, &m_sceneColorTex);
    glBindTexture(GL_TEXTURE_2D, m_sceneColorTex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, w, h, 0,
                 GL_RGBA, GL_FLOAT, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                           GL_TEXTURE_2D, m_sceneColorTex, 0);
    GLenum attachments[1] = { GL_COLOR_ATTACHMENT0 };
    glDrawBuffers(1, attachments);

    // 3) Depth buffer
    glGenRenderbuffers(1, &m_sceneDepthRBO);
    glBindRenderbuffer(GL_RENDERBUFFER, m_sceneDepthRBO);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, w, h);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,
                              GL_RENDERBUFFER, m_sceneDepthRBO);

    // Check
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        std::cout << "Scene FBO is NOT complete!" << std::endl;
    }

    // unbind
    glBindFramebuffer(GL_FRAMEBUFFER, 0);


    // ============================
    // NEW: Bright-pass FBO
    // ============================
    glGenFramebuffers(1, &m_brightFBO);
    glBindFramebuffer(GL_FRAMEBUFFER, m_brightFBO);

    // bright texture
    glGenTextures(1, &m_brightTex);
    glBindTexture(GL_TEXTURE_2D, m_brightTex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0,
                 GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                           GL_TEXTURE_2D, m_brightTex, 0);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        std::cout << "Bright FBO NOT complete!\n";
    }

    glBindFramebuffer(GL_FRAMEBUFFER, 0);


    // ============================
    // NEW: Blur FBOs (ping-pong)
    // ============================
    glGenFramebuffers(1, &m_pingFBO);
    glGenFramebuffers(1, &m_pongFBO);

    glGenTextures(1, &m_pingTex);
    glGenTextures(1, &m_pongTex);

    GLuint blurTextures[2] = { m_pingTex, m_pongTex };
    GLuint blurFBOs[2] = { m_pingFBO, m_pongFBO };

    for (int i = 0; i < 2; i++) {
        glBindTexture(GL_TEXTURE_2D, blurTextures[i]);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0,
                     GL_RGBA, GL_UNSIGNED_BYTE, NULL);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        glBindFramebuffer(GL_FRAMEBUFFER, blurFBOs[i]);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                               GL_TEXTURE_2D, blurTextures[i], 0);

        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
            std::cout << "Blur FBO " << i << " NOT complete!\n";
        }
    }
    glBindFramebuffer(GL_FRAMEBUFFER, 0);


    // ============================
    // NEW: Fullscreen Quad
    // ============================
    float quadVertices[] = {
        // positions   // texcoords
        -1.0, -1.0,     0.0, 0.0,
        1.0, -1.0,     1.0, 0.0,
        1.0,  1.0,     1.0, 1.0,

        -1.0, -1.0,     0.0, 0.0,
        1.0,  1.0,     1.0, 1.0,
        -1.0,  1.0,     0.0, 1.0
    };

    glGenVertexArrays(1, &m_quadVAO);
    glGenBuffers(1, &m_quadVBO);

    glBindVertexArray(m_quadVAO);
    glBindBuffer(GL_ARRAY_BUFFER, m_quadVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));

    glBindVertexArray(0);

    // Load background texture
    m_backgroundTex = loadTextureFromResource(":/resources/textures/bg.png");

    // =============================
    // Initialize default scene
    // =============================
    createDefaultScene(m_renderData);
    buildVAOsFromRenderData();

    // Initialize camera
    m_camera.setCameraData(
        m_renderData.cameraData.pos,
        m_renderData.cameraData.look,
        m_renderData.cameraData.up,
        m_renderData.cameraData.heightAngle
        );
    m_camera.setAspectRatio(float(width()) / float(height()));
    m_camera.setNearFar(0.1f, 100.f);

}

void Realtime::paintGL() {
    // === NEW: Before each frame starts, the depth test must be re-enabled (because bright pass was disabled after the previous frame).
    glEnable(GL_DEPTH_TEST);
    GLuint screenFBO = defaultFramebufferObject();

    //===  NEW: Scene Pass ===
    glBindFramebuffer(GL_FRAMEBUFFER, m_sceneFBO);
    glViewport(0, 0, width() * m_devicePixelRatio, height() * m_devicePixelRatio);

    // 1) Clear the scene framebuffer
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // 2) Bail out if we have nothing to draw
    if (!m_shader) {
        return;
    }

    // 3) Bind the shader once per frame
    glUseProgram(m_shader);

    // 4) Upload view & projection matrices derived from the current camera
    float timeSec = m_scrollTime;
    glm::mat4 view = m_camera.getViewMatrix();
    glm::mat4 proj = m_camera.getProjMatrix();

    if (GLint uView = glGetUniformLocation(m_shader, "view"); uView != -1) {
        glUniformMatrix4fv(uView, 1, GL_FALSE, &view[0][0]);
    }
    if (GLint uProj = glGetUniformLocation(m_shader, "proj"); uProj != -1) {
        glUniformMatrix4fv(uProj, 1, GL_FALSE, &proj[0][0]);
    }

    // 5) Push the scene-wide lighting constants (global coefficients & camera position)
    const SceneGlobalData &g = m_renderData.globalData;
    if (GLint loc = glGetUniformLocation(m_shader, "global_ka"); loc != -1)
        glUniform1f(loc, g.ka);
    if (GLint loc = glGetUniformLocation(m_shader, "global_kd"); loc != -1)
        glUniform1f(loc, g.kd);
    if (GLint loc = glGetUniformLocation(m_shader, "global_ks"); loc != -1)
        glUniform1f(loc, g.ks);
    if (GLint loc = glGetUniformLocation(m_shader, "timeSec"); loc != -1)
        glUniform1f(loc, timeSec);
    if (GLint loc = glGetUniformLocation(m_shader, "bgScrollOffset"); loc != -1)
        glUniform1f(loc, m_bgScrollOffset);
    if (GLint loc = glGetUniformLocation(m_shader, "starScrollSpeed"); loc != -1)
        glUniform1f(loc, 0.0025f);

    glm::vec3 camPos = glm::vec3(m_renderData.cameraData.pos);
    if (GLint loc = glGetUniformLocation(m_shader, "cameraPos"); loc != -1)
        glUniform3f(loc, camPos.x, camPos.y, camPos.z);

    // 6) Upload lighting parameters
    glm::vec3 lightPos(5.f, 5.f, 5.f);
    glm::vec3 lightColor(1.05f, 0.95f, 0.75f); // warm tone for highlight/bloom

    if (GLint loc = glGetUniformLocation(m_shader, "lightPos"); loc != -1)
        glUniform3fv(loc, 1, &lightPos[0]);
    if (GLint loc = glGetUniformLocation(m_shader, "lightColor"); loc != -1)
        glUniform3fv(loc, 1, &lightColor[0]);


    // For monster：Cache GLB-related uniform
    GLint uUseMeshTexture = glGetUniformLocation(m_shader, "useMeshTexture");
    GLint uUseNormalMap   = glGetUniformLocation(m_shader, "useNormalMap");
    GLint uMeshEmissive   = glGetUniformLocation(m_shader, "meshEmissive");
    GLint uUseSkinning    = glGetUniformLocation(m_shader, "useSkinning");
    GLint uUseEmissiveTex = glGetUniformLocation(m_shader, "useMeshEmissiveTex");
    GLint uEnableStarfield = glGetUniformLocation(m_shader, "enableStarfield");


    // 7) Draw each mesh with its own material and model matrix
    // for (int i = 0; i < static_cast<int>(m_vaos.size()); ++i) {
    // The for loop is modified
    for (size_t i = 0; i < m_renderData.shapes.size(); ++i) {
        // glBindVertexArray(m_vaos[i]);

        // const RenderShapeData &shapeData = m_renderData.shapes[i];


        // For monster
        const RenderShapeData &shapeData = m_renderData.shapes[i];

        if (shapeData.primitive.type == PrimitiveType::PRIMITIVE_MESH) {
            if (uUseMeshTexture != -1) glUniform1i(uUseMeshTexture, 0);
            if (uUseNormalMap   != -1) glUniform1i(uUseNormalMap, 0);
            if (uMeshEmissive   != -1) glUniform3f(uMeshEmissive, 0.f, 0.f, 0.f);
            if (uUseEmissiveTex != -1) glUniform1i(uUseEmissiveTex, 0);
            if (uUseSkinning    != -1) glUniform1i(uUseSkinning, 0);
            if (uEnableStarfield != -1) glUniform1i(uEnableStarfield, 0);
            drawMeshPrimitive(i, shapeData);
            continue;
        }

        // Reset the GLB uniform to avoid residual
        if (uUseMeshTexture != -1) glUniform1i(uUseMeshTexture, 0);
        if (uUseNormalMap   != -1) glUniform1i(uUseNormalMap, 0);
        if (uMeshEmissive   != -1) glUniform3f(uMeshEmissive, 0.f, 0.f, 0.f);
        if (uUseEmissiveTex != -1) glUniform1i(uUseEmissiveTex, 0);
        if (uUseSkinning    != -1) glUniform1i(uUseSkinning, 0);

        if (i >= m_vaos.size() || m_vaos[i] == 0) continue;
        glBindVertexArray(m_vaos[i]);



        const SceneMaterial &mat = shapeData.primitive.material;
        if (GLint loc = glGetUniformLocation(m_shader, "matAmbient"); loc != -1)
            glUniform4fv(loc, 1, &mat.cAmbient[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matDiffuse"); loc != -1)
            glUniform4fv(loc, 1, &mat.cDiffuse[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matSpecular"); loc != -1)
            glUniform4fv(loc, 1, &mat.cSpecular[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matEmissive"); loc != -1)
            glUniform4fv(loc, 1, &mat.cEmissive[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matShininess"); loc != -1)
            glUniform1f(loc, mat.shininess);

        bool useBackgroundTex = false;
        bool restoreCull = false;
        if (shapeData.primitive.type == PrimitiveType::PRIMITIVE_SPHERE && m_backgroundTex != 0) {
            float approxScale = glm::length(glm::vec3(shapeData.ctm[0]));
            if (approxScale > 10.f) {
                useBackgroundTex = true;
            }
        }
        if (GLint loc = glGetUniformLocation(m_shader, "useBackgroundTex"); loc != -1) {
            glUniform1i(loc, useBackgroundTex ? 1 : 0);
        }
        if (uEnableStarfield != -1) {
            glUniform1i(uEnableStarfield, useBackgroundTex ? 1 : 0);
        }
        if (useBackgroundTex) {
            glActiveTexture(GL_TEXTURE5);
            glBindTexture(GL_TEXTURE_2D, m_backgroundTex);
            if (GLint loc = glGetUniformLocation(m_shader, "backgroundTex"); loc != -1) {
                glUniform1i(loc, 5);
            }
            if (glIsEnabled(GL_CULL_FACE)) {
                glDisable(GL_CULL_FACE);
                restoreCull = true;
            }
            glDisable(GL_DEPTH_TEST);
            glDepthMask(GL_FALSE);
        } else {
            glActiveTexture(GL_TEXTURE5);
            glBindTexture(GL_TEXTURE_2D, 0);
        }

        glm::mat4 model = shapeData.ctm;
        if (GLint loc = glGetUniformLocation(m_shader, "model"); loc != -1)
            glUniformMatrix4fv(loc, 1, GL_FALSE, &model[0][0]);

        glDrawArrays(GL_TRIANGLES, 0, m_vboSizes[i]);

        if (useBackgroundTex) {
            if (restoreCull) {
                glEnable(GL_CULL_FACE);
            }
            glDepthMask(GL_TRUE);
            glEnable(GL_DEPTH_TEST);
            glActiveTexture(GL_TEXTURE5);
            glBindTexture(GL_TEXTURE_2D, 0);
            glActiveTexture(GL_TEXTURE0);
        }

        glBindVertexArray(0);
    }

    // 8) Unbind the shader + scene FBO before post-processing
    glUseProgram(0);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    // ========================
    // NEW: blit FBO to screen (screen pass)
    // ========================

    // =========================
    // Pass 2: Bright-pass (bloom)
    // =========================
    glBindFramebuffer(GL_FRAMEBUFFER, m_brightFBO);
    glViewport(0, 0, width()*m_devicePixelRatio, height()*m_devicePixelRatio);
    glDisable(GL_DEPTH_TEST);
    glClear(GL_COLOR_BUFFER_BIT);

    glUseProgram(m_brightShader);

    // sceneColorTex -> uScene
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, m_sceneColorTex);
    glUniform1i(glGetUniformLocation(m_brightShader, "uScene"), 0);

    glBindVertexArray(m_quadVAO);
    glDrawArrays(GL_TRIANGLES, 0, 6);
    glBindVertexArray(0);

    // =============================
    // Pass 2.5: Gaussian Blur (Ping-Pong)
    // =============================
    bool horizontal = true;
    bool firstIter = true;
    int blurAmount = 15;  // moderate bloom

    glUseProgram(m_blurShader);

    if (GLint loc = glGetUniformLocation(m_blurShader, "blurRadius"); loc != -1) {
        glUniform1f(loc, 0.9f); // smaller blur kernel
    }

    // if blur amount is even, use pong; if blur amount is odd, use ping
    for (int i = 0; i < blurAmount; i++) {

        glBindFramebuffer(GL_FRAMEBUFFER, horizontal ? m_pingFBO : m_pongFBO);

        glUniform1i(glGetUniformLocation(m_blurShader, "horizontal"), horizontal);

        glActiveTexture(GL_TEXTURE0);

        // first iteration uses brightTex
        GLuint tex = firstIter ? m_brightTex :
                         (horizontal ? m_pongTex : m_pingTex);

        glBindTexture(GL_TEXTURE_2D, tex);
        glUniform1i(glGetUniformLocation(m_blurShader, "image"), 0);

        glBindVertexArray(m_quadVAO);
        glDrawArrays(GL_TRIANGLES, 0, 6);

        horizontal = !horizontal;
        if (firstIter) firstIter = false;
    }

    // =========================
    // Pass 3: Combine (scene + bloom)
    // =========================
    glBindFramebuffer(GL_FRAMEBUFFER, screenFBO);
    glViewport(0, 0, width()*m_devicePixelRatio, height()*m_devicePixelRatio);
    glDisable(GL_DEPTH_TEST);
    glClear(GL_COLOR_BUFFER_BIT);

    glUseProgram(m_screenShader);

    // sceneTex
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, m_sceneColorTex);
    glUniform1i(glGetUniformLocation(m_screenShader, "sceneTex"), 0);

    // bloomTexFinal (chosse from ping/pong)
    GLuint bloomTexFinal = (blurAmount % 2 == 0 ? m_pongTex : m_pingTex);

    // bloomTex
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, bloomTexFinal);
    glUniform1i(glGetUniformLocation(m_screenShader, "bloomTex"), 1);

    if (GLint loc = glGetUniformLocation(m_screenShader, "bloomStrength"); loc != -1) {
        glUniform1f(loc, settings.bloomStrength);
    }

    glBindVertexArray(m_quadVAO);
    glDrawArrays(GL_TRIANGLES, 0, 6);
    glBindVertexArray(0);
}

void Realtime::resizeGL(int w, int h) {
    glViewport(0, 0, w * m_devicePixelRatio, h * m_devicePixelRatio);

    int W = w * m_devicePixelRatio;
    int H = h * m_devicePixelRatio;

    // scene FBO
    glBindTexture(GL_TEXTURE_2D, m_sceneColorTex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, W, H, 0,
                 GL_RGBA, GL_FLOAT, NULL);

    // bright FBO
    glBindTexture(GL_TEXTURE_2D, m_brightTex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, W, H, 0,
                 GL_RGBA, GL_FLOAT, NULL);

    // blur FBOs
    glBindTexture(GL_TEXTURE_2D, m_pingTex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, W, H, 0,
                 GL_RGBA, GL_FLOAT, NULL);

    glBindTexture(GL_TEXTURE_2D, m_pongTex);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, W, H, 0,
                 GL_RGBA, GL_FLOAT, NULL);

    // depth buffer
    glBindRenderbuffer(GL_RENDERBUFFER, m_sceneDepthRBO);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, W, H);
}

void Realtime::sceneChanged() {
    // m_renderData = RenderData();

    // if (SceneParser::parse(m_sceneFilePath, m_renderData)) {
    //     // load camera data
    //     m_camera.setCameraData(
    //         m_renderData.cameraData.pos,
    //         m_renderData.cameraData.look,
    //         m_renderData.cameraData.up,
    //         m_renderData.cameraData.heightAngle
    //     );

    //     m_camera.setAspectRatio(float(width()) / float(height()));
    //     m_camera.setNearFar(settings.nearPlane, settings.farPlane);
    // } else {
    //     std::cout << "ERROR: Scene parsing failed!" << std::endl;
    // }

    // // regenerate VAO / VBO
    // buildVAOsFromRenderData();


    // For monster
    if (m_sceneFilePath.empty()) {
        std::cerr << "No scene file specified." << std::endl;
        return;
    }

    RenderData parsed;
    if (!SceneParser::parse(m_sceneFilePath, parsed)) {
        std::cerr << "Failed to parse scene: " << m_sceneFilePath << std::endl;
        return;
    }

    // use the default starry sky scene as the base
    RenderData combined;
    createDefaultScene(combined);

    // Override the default values with the global coefficient/camera in JSON
    // combined.globalData = parsed.globalData;
    // combined.cameraData = parsed.cameraData;

    // Lighting and shape: Add the content in the JSON on the basis of the starry sky scene
    combined.lights.insert(combined.lights.end(),
                           parsed.lights.begin(), parsed.lights.end());
    combined.shapes.insert(combined.shapes.end(),
                           parsed.shapes.begin(), parsed.shapes.end());

    m_renderData = std::move(combined);

    // Update camera parameters
    m_camera.setCameraData(
        m_renderData.cameraData.pos,
        m_renderData.cameraData.look,
        m_renderData.cameraData.up,
        m_renderData.cameraData.heightAngle
        );
    m_camera.setAspectRatio(float(width()) / float(height()));
    m_camera.setNearFar(settings.nearPlane, settings.farPlane);

    buildVAOsFromRenderData();



    update();
}

// load VAOn from render data
void Realtime::buildVAOsFromRenderData()
{
    makeCurrent();

    // clean old VAO / VBO
    for (GLuint vao : m_vaos) {
        glDeleteVertexArrays(1, &vao);
    }
    for (GLuint vbo : m_vbos) {
        glDeleteBuffers(1, &vbo);
    }
    m_vaos.clear();
    m_vbos.clear();
    m_vboSizes.clear();

    // For monster
    m_meshFiles.clear();
    m_meshFiles.reserve(m_renderData.shapes.size());

    // generate a VAO + VBO for each primitive
    for (const RenderShapeData &shape : m_renderData.shapes)
    {
        // For monster
        m_meshFiles.emplace_back();   // place a placeholder to ensure index consistency

        if (shape.primitive.type == PrimitiveType::PRIMITIVE_MESH) {
            std::string resolved = resolveMeshPath(shape.primitive.meshfile);
            m_meshFiles.back() = resolved;
            if (!resolved.empty() && !ensureGlbModelLoaded(resolved)) {
                std::cerr << "Failed to load GLB: " << resolved << std::endl;
            }

            m_vaos.push_back(0);   // Placeholder: The actual VAO has already been created in GLBLoader
            m_vbos.push_back(0);
            m_vboSizes.push_back(0);
            continue;              // No more vertex data is generated
        }


        std::vector<float> vertexData;

        // ---- generates vertex normal data of the primitive type ----
        switch (shape.primitive.type) {
        case PrimitiveType::PRIMITIVE_CUBE:
            m_cube.updateParams(settings.shapeParameter1);
            vertexData = m_cube.generateShape();
            break;
        case PrimitiveType::PRIMITIVE_SPHERE:
            m_sphere.updateParams(settings.shapeParameter1,
                                  settings.shapeParameter2);
            vertexData = m_sphere.generateShape();
            break;
        case PrimitiveType::PRIMITIVE_CONE:
            m_cone.updateParams(settings.shapeParameter1,
                                settings.shapeParameter2);
            vertexData = m_cone.generateShape();
            break;
        case PrimitiveType::PRIMITIVE_CYLINDER:
            m_cylinder.updateParams(settings.shapeParameter1,
                                    settings.shapeParameter2);
            vertexData = m_cylinder.generateShape();
            break;
        case PrimitiveType::PRIMITIVE_STAR:
            m_star.updateParams(settings.shapeParameter1,
                                settings.shapeParameter2);
            vertexData = m_star.generateShape();
            break;
        default:
            continue;
        }

        if (vertexData.empty()) {
            // For monster
            m_vaos.push_back(0);
            m_vbos.push_back(0);
            m_vboSizes.push_back(0);

            continue;
        }

        // ---- create and bind VAO / VBO ----
        GLuint vao, vbo;
        glGenVertexArrays(1, &vao);
        glGenBuffers(1, &vbo);

        glBindVertexArray(vao);
        glBindBuffer(GL_ARRAY_BUFFER, vbo);

        glBufferData(GL_ARRAY_BUFFER,
                     sizeof(float) * vertexData.size(),
                     vertexData.data(),
                     GL_STATIC_DRAW);

        int stride = 6 * sizeof(float);   // 3 pos + 3 normal

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE,
                              stride, (void*)0);

        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));

        // For monster
        // Give the constant value of attribute 2/3/4
        glDisableVertexAttribArray(2);
        glVertexAttribI4i(2, 0, 0, 0, 0);

        glDisableVertexAttribArray(3);
        glVertexAttrib4f(3, 1.f, 0.f, 0.f, 0.f);

        glDisableVertexAttribArray(4);
        glVertexAttrib2f(4, 0.f, 0.f);


        // ---- unbind ----
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);

        // push back
        m_vaos.push_back(vao);
        m_vbos.push_back(vbo);
        m_vboSizes.push_back(static_cast<int>(vertexData.size() / 6));

    }
}


void Realtime::settingsChanged() {
    if (!m_renderData.shapes.empty()) {
        buildVAOsFromRenderData();
        m_camera.setAspectRatio(float(width()) / float(height()));
        m_camera.setNearFar(settings.nearPlane, settings.farPlane);
    }
    update(); // asks for a PaintGL() call to occur
}

void Realtime::timerEvent(QTimerEvent *event) {
    Q_UNUSED(event);
    float deltaSec = m_elapsedTimer.restart() * 0.001f;
    m_scrollTime += deltaSec;
    m_bgScrollOffset += deltaSec * settings.bgScrollSpeed;
    if (m_bgScrollOffset >= 1.f) {
        m_bgScrollOffset = std::fmod(m_bgScrollOffset, 1.f);
    } else if (m_bgScrollOffset < 0.f) {
        m_bgScrollOffset = 1.f - std::fmod(-m_bgScrollOffset, 1.f);
    }

    // For monster: Promote skeletal animation
    updateGlbAnimations(deltaSec);


    update();
}

// ================== Camera Movement! ---- Not needed

// void Realtime::keyPressEvent(QKeyEvent *event) {
//     m_keyMap[Qt::Key(event->key())] = true;
// }

// void Realtime::keyReleaseEvent(QKeyEvent *event) {
//     m_keyMap[Qt::Key(event->key())] = false;
// }

// void Realtime::mousePressEvent(QMouseEvent *event) {
//     if (event->buttons().testFlag(Qt::LeftButton)) {
//         m_mouseDown = true;
//         m_prev_mouse_pos = glm::vec2(event->position().x(), event->position().y());
//     }
// }

// void Realtime::mouseReleaseEvent(QMouseEvent *event) {
//     if (!event->buttons().testFlag(Qt::LeftButton)) {
//         m_mouseDown = false;
//     }
// }

// void Realtime::mouseMoveEvent(QMouseEvent *event) {
//     if (m_mouseDown) {
//         int posX = event->position().x();
//         int posY = event->position().y();
//         int deltaX = posX - m_prev_mouse_pos.x;
//         int deltaY = posY - m_prev_mouse_pos.y;
//         m_prev_mouse_pos = glm::vec2(posX, posY);

//         const float sensitivity = 0.005f;
//         m_camera.rotateAroundWorldUp(-deltaX * sensitivity);
//         m_camera.rotateAroundRight(-deltaY * sensitivity);

//         update(); // asks for a PaintGL() call to occur
//     }
// }

// void Realtime::timerEvent(QTimerEvent *event) {
//     int elapsedms   = m_elapsedTimer.elapsed();
//     float deltaTime = elapsedms * 0.001f;
//     m_elapsedTimer.restart();

//     const float moveSpeed = 5.f;
//     glm::vec3 movement(0.f);

//     glm::vec3 forward = m_camera.getForward();
//     glm::vec3 right = m_camera.getRightVector();

//     if (m_keyMap[Qt::Key_W]) movement += forward;
//     if (m_keyMap[Qt::Key_S]) movement -= forward;
//     if (m_keyMap[Qt::Key_D]) movement += right;
//     if (m_keyMap[Qt::Key_A]) movement -= right;
//     if (m_keyMap[Qt::Key_Space]) movement += glm::vec3(0.f, 1.f, 0.f);
//     if (m_keyMap[Qt::Key_Control]) movement += glm::vec3(0.f, -1.f, 0.f);

//     if (glm::length(movement) > 0.f) {
//         movement = glm::normalize(movement) * moveSpeed * deltaTime;
//         m_camera.translate(movement);
//     }

//     update(); // asks for a PaintGL() call to occur
// }

// DO NOT EDIT
void Realtime::saveViewportImage(std::string filePath) {
    // Make sure we have the right context and everything has been drawn
    makeCurrent();

    // int fixedWidth = 1024;
    // int fixedHeight = 768;

    GLint viewport[4];
    glGetIntegerv(GL_VIEWPORT, viewport);
    int fixedWidth = viewport[2];
    int fixedHeight = viewport[3];

    // Create Frame Buffer
    GLuint fbo;
    glGenFramebuffers(1, &fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, fbo);

    // Create a color attachment texture
    GLuint texture;
    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, fixedWidth, fixedHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0);

    // Optional: Create a depth buffer if your rendering uses depth testing
    GLuint rbo;
    glGenRenderbuffers(1, &rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, fixedWidth, fixedHeight);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rbo);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        std::cerr << "Error: Framebuffer is not complete!" << std::endl;
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        return;
    }

    // Render to the FBO
    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
    glViewport(0, 0, fixedWidth, fixedHeight);

    // Clear and render your scene here
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    paintGL();

    // Read pixels from framebuffer
    std::vector<unsigned char> pixels(fixedWidth * fixedHeight * 3);
    glReadPixels(0, 0, fixedWidth, fixedHeight, GL_RGB, GL_UNSIGNED_BYTE, pixels.data());

    // Unbind the framebuffer to return to default rendering to the screen
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    // Convert to QImage
    QImage image(pixels.data(), fixedWidth, fixedHeight, QImage::Format_RGB888);
    QImage flippedImage = image.mirrored(); // Flip the image vertically

    // Save to file using Qt
    QString qFilePath = QString::fromStdString(filePath);
    if (!flippedImage.save(qFilePath)) {
        std::cerr << "Failed to save image to " << filePath << std::endl;
    }

    // Clean up
    glDeleteTextures(1, &texture);
    glDeleteRenderbuffers(1, &rbo);
    glDeleteFramebuffers(1, &fbo);
}

void Realtime::setSceneFilePath(std::string path) { m_sceneFilePath = path; }



// For monster
void Realtime::drawMeshPrimitive(size_t shapeIndex, const RenderShapeData &shape) {
    if (shapeIndex >= m_meshFiles.size()) return;
    const std::string &meshfile = m_meshFiles[shapeIndex];
    if (meshfile.empty()) return;

    auto it = m_glbModels.find(meshfile);
    if (it == m_glbModels.end() || !it->second.loaded) return;
    GLBModel &model = it->second;

    GLint locModel         = glGetUniformLocation(m_shader, "model");
    GLint locUseMeshTex    = glGetUniformLocation(m_shader, "useMeshTexture");
    GLint locMeshTex       = glGetUniformLocation(m_shader, "meshTexture");
    GLint locUseNormalMap  = glGetUniformLocation(m_shader, "useNormalMap");
    GLint locNormalMapTex  = glGetUniformLocation(m_shader, "normalMapTexture");
    GLint locMeshEmissive  = glGetUniformLocation(m_shader, "meshEmissive");
    GLint locUseEmissiveTex = glGetUniformLocation(m_shader, "useMeshEmissiveTex");
    GLint locEmissiveTex   = glGetUniformLocation(m_shader, "meshEmissiveTex");
    GLint locUseSkinning   = glGetUniformLocation(m_shader, "useSkinning");
    GLint locBoneMatrices  = glGetUniformLocation(m_shader, "boneMatrices[0]");

    // New: rotate the model
    // glm::mat4 modelMatrix = shape.ctm;
    // modelMatrix = glm::scale(modelMatrix, glm::vec3(0.6f));          // scale to be 50%
    // modelMatrix = glm::rotate(modelMatrix, glm::radians(180.0f), glm::vec3(1.f, 0.f, 0.f)); // turn it right(vertical)
    // modelMatrix = glm::rotate(modelMatrix, glm::radians(90.0f),  glm::vec3(0.f, 1.f, 0.f)); // turn it left

    glm::mat4 modelMatrix = shape.ctm;
    std::string name = meshfile;
    if (name.find("alien_fish") != std::string::npos) {
        modelMatrix = glm::scale(modelMatrix, glm::vec3(0.5f));
        modelMatrix = glm::rotate(modelMatrix, glm::radians(180.0f), glm::vec3(1.f, 0.f, 0.f)); // turn it right(vertical)
        modelMatrix = glm::rotate(modelMatrix, glm::radians(90.0f),  glm::vec3(0.f, 1.f, 0.f)); // turn it left
    } else if (name.find("titan") != std::string::npos) {
        modelMatrix = glm::scale(modelMatrix, glm::vec3(0.01f));
        modelMatrix = glm::rotate(modelMatrix, glm::radians(90.f), glm::vec3(0.f, 1.f, 0.f));
    } else if (name.find("glow_whale") != std::string::npos) {
        modelMatrix = glm::scale(modelMatrix, glm::vec3(0.1f));
        modelMatrix = glm::rotate(modelMatrix, glm::radians(180.f), glm::vec3(0.f, 1.f, 0.f));
        modelMatrix = glm::rotate(modelMatrix, glm::radians(90.0f),  glm::vec3(0.f, 1.f, 0.f));
    }


    if (locModel != -1) {
        glUniformMatrix4fv(locModel, 1, GL_FALSE, &modelMatrix[0][0]);
    }

    bool hasSkinning = model.hasSkin && !model.skin.boneMatrices.empty();
    if (locUseSkinning != -1) {
        glUniform1i(locUseSkinning, hasSkinning ? 1 : 0);
    }
    if (hasSkinning && locBoneMatrices != -1) {
        GLsizei boneCount = std::min<int>(model.skin.boneMatrices.size(), 200);
        if (boneCount > 0) {
            glUniformMatrix4fv(locBoneMatrices,
                               boneCount,
                               GL_FALSE,
                               &model.skin.boneMatrices[0][0][0]);
        }
    }

    for (const GLBMesh &mesh : model.meshes) {
        if (mesh.vao == 0 || mesh.indexCount == 0) continue;

        // Combined materials: The scene materials are set as the default. If GLB has materials, they will be overridden
        SceneMaterial mat = shape.primitive.material;
        const GLBMaterial *glbMaterial = nullptr;
        if (mesh.materialIndex >= 0 &&
            mesh.materialIndex < static_cast<int>(model.materials.size())) {
            glbMaterial = &model.materials[mesh.materialIndex];
        }
        if (glbMaterial) {
            mat.cAmbient  = glm::vec4(glbMaterial->ambient, 1.f);
            mat.cDiffuse  = glm::vec4(glbMaterial->diffuse, 1.f);
            mat.cSpecular = glm::vec4(glbMaterial->specular, 1.f);
            mat.shininess = glbMaterial->shininess;
        }

        if (GLint loc = glGetUniformLocation(m_shader, "matAmbient"); loc != -1)
            glUniform4fv(loc, 1, &mat.cAmbient[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matDiffuse"); loc != -1)
            glUniform4fv(loc, 1, &mat.cDiffuse[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matSpecular"); loc != -1)
            glUniform4fv(loc, 1, &mat.cSpecular[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matEmissive"); loc != -1)
            glUniform4fv(loc, 1, &mat.cEmissive[0]);
        if (GLint loc = glGetUniformLocation(m_shader, "matShininess"); loc != -1)
            glUniform1f(loc, mat.shininess);

        // Texture/Glow
        bool hasTexture = false;
        GLuint textureId = 0;
        bool hasNormalMap = false;
        GLuint normalTexId = 0;
        bool hasEmissiveMap = false;
        GLuint emissiveTexId = 0;
        if (glbMaterial && glbMaterial->hasBaseColorTexture) {
            int texIdx = glbMaterial->baseColorTextureIndex;
            if (texIdx >= 0 && texIdx < static_cast<int>(model.textures.size())) {
                const GLBTexture &tex = model.textures[texIdx];
                if (tex.loaded && tex.textureId != 0) {
                    hasTexture = true;
                    textureId = tex.textureId;
                }
            }
        }
        if (locUseMeshTex != -1) glUniform1i(locUseMeshTex, hasTexture ? 1 : 0);
        if (hasTexture) {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, textureId);
            if (locMeshTex != -1) glUniform1i(locMeshTex, 0);
        } else {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, 0);
        }
        if (glbMaterial && glbMaterial->normalTextureIndex >= 0 &&
            meshfile.find("titan") != std::string::npos) {
            int normalIdx = glbMaterial->normalTextureIndex;
            if (normalIdx >= 0 && normalIdx < static_cast<int>(model.textures.size())) {
                const GLBTexture &nTex = model.textures[normalIdx];
                if (nTex.loaded && nTex.textureId != 0) {
                    hasNormalMap = true;
                    normalTexId = nTex.textureId;
                }
            }
        }
        if (locUseNormalMap != -1) glUniform1i(locUseNormalMap, hasNormalMap ? 1 : 0);
        if (hasNormalMap) {
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, normalTexId);
            if (locNormalMapTex != -1) glUniform1i(locNormalMapTex, 1);
        } else {
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, 0);
        }
        glActiveTexture(GL_TEXTURE0);

        if (glbMaterial && glbMaterial->emissiveTextureIndex >= 0) {
            int emissiveIdx = glbMaterial->emissiveTextureIndex;
            if (emissiveIdx >= 0 && emissiveIdx < static_cast<int>(model.textures.size())) {
                const GLBTexture &eTex = model.textures[emissiveIdx];
                if (eTex.loaded && eTex.textureId != 0) {
                    hasEmissiveMap = true;
                    emissiveTexId = eTex.textureId;
                }
            }
        }
        if (locUseEmissiveTex != -1) {
            glUniform1i(locUseEmissiveTex, hasEmissiveMap ? 1 : 0);
        }
        if (hasEmissiveMap) {
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, emissiveTexId);
            if (locEmissiveTex != -1) glUniform1i(locEmissiveTex, 2);
        } else {
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, 0);
        }
        glActiveTexture(GL_TEXTURE0);

        glm::vec3 emissive = glbMaterial ? glbMaterial->emissiveFactor : glm::vec3(0.f);
        if (locMeshEmissive != -1) {
            glUniform3f(locMeshEmissive, emissive.x, emissive.y, emissive.z);
        }

        // Draw
        glBindVertexArray(mesh.vao);
        if (mesh.hasIndices && mesh.ebo != 0) {
            glDrawElements(GL_TRIANGLES, mesh.indexCount, GL_UNSIGNED_INT, nullptr);
        } else {
            glDrawArrays(GL_TRIANGLES, 0, mesh.indexCount);
        }
        glBindVertexArray(0);
    }

    // After the drawing is completed, restore the default state
    if (locUseMeshTex != -1) glUniform1i(locUseMeshTex, 0);
    if (locUseNormalMap != -1) glUniform1i(locUseNormalMap, 0);
    if (locMeshEmissive != -1) glUniform3f(locMeshEmissive, 0.f, 0.f, 0.f);
    if (locUseEmissiveTex != -1) glUniform1i(locUseEmissiveTex, 0);
    if (locUseSkinning != -1) glUniform1i(locUseSkinning, 0);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, 0);
    glActiveTexture(GL_TEXTURE2);
    glBindTexture(GL_TEXTURE_2D, 0);
}

std::string Realtime::resolveMeshPath(const std::string &meshfile) const {
    namespace fs = std::filesystem;
    if (meshfile.empty()) return {};

    fs::path input(meshfile);
    std::error_code ec;

    auto existsCanon = [&](const fs::path &p) -> fs::path {
        if (p.empty()) return {};
        if (fs::exists(p, ec)) {
            fs::path canonical = fs::weakly_canonical(p, ec);
            return ec ? p : canonical;
        }
        return {};
    };

    if (input.is_absolute()) {
        return existsCanon(input).string();
    }

    std::vector<fs::path> searchDirs;
    if (!m_sceneFilePath.empty()) {
        searchDirs.emplace_back(fs::path(m_sceneFilePath).parent_path());
    }
#ifdef PROJECT_SOURCE_DIR
    searchDirs.emplace_back(fs::path(PROJECT_SOURCE_DIR));
    searchDirs.emplace_back(fs::path(PROJECT_SOURCE_DIR) / "resources");
#endif
    QString appDir = QCoreApplication::applicationDirPath();
    searchDirs.emplace_back(fs::path(appDir.toStdString()));
    searchDirs.emplace_back(fs::path(appDir.toStdString()) / "..");
    searchDirs.emplace_back(fs::current_path());

    for (const fs::path &base : searchDirs) {
        fs::path candidate = base / input;
        fs::path resolved = existsCanon(candidate);
        if (!resolved.empty()) {
            return resolved.string();
        }
    }

    return input.string(); // fallback
}

bool Realtime::ensureGlbModelLoaded(const std::string &meshfile) {
    if (meshfile.empty()) return false;

    auto it = m_glbModels.find(meshfile);
    if (it != m_glbModels.end() && it->second.loaded) {
        return true;
    }

    makeCurrent(); // 确保有 GL context
    GLBModel model;
    if (!GLBLoader::loadGLB(meshfile, model)) {
        return false;
    }
    if (model.hasSkin) {
        GLBLoader::updateAnimation(model, 0.0f, -1); // 初始化到 bind pose
    }
    m_glbModels[meshfile] = std::move(model);
    return true;
}

void Realtime::updateGlbAnimations(float deltaSec) {
    if (m_glbModels.empty()) return;

    m_glbAnimTime += deltaSec;
    for (auto &[path, model] : m_glbModels) {
        if (!model.hasSkin) continue;
        if (!model.animations.empty()) {
            float duration = model.animations[0].duration;
            float t = duration > 0.f ? std::fmod(m_glbAnimTime, duration) : m_glbAnimTime;
            GLBLoader::updateAnimation(model, t, 0);
        } else {
            GLBLoader::updateAnimation(model, 0.0f, -1);
        }
    }
}

void Realtime::deleteGlbResources() {
    for (auto &[path, model] : m_glbModels) {
        GLBLoader::cleanup(model);
    }
    m_glbModels.clear();
}
